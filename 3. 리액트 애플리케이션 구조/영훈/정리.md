## 리액트 애플리케이션 구조

프로젝트 구조에 왜 신경을 써야 할까?

잘 갖춰진 구조는 유지보수하기 쉽고 새로운 팀원이 합류했을 때 이해하기 쉽고 기능을 확장하기 쉬운 덕분에 프로젝트 성공에 전반적인 영향을 끼치게 된다.

반면에 비효율적인 구조는 코드 스멜을 유발시키고 코드 복잡도를 높이며 기술 부채가 생기기 쉬운 환경이 될 수 있다.

---

### 3.1 구조화되지 않은 프로젝트의 문제점

구조화가 덜 된 프로젝트의 문제점은 코드베이스를 효과적으로 관리하고 유지보수가 어렵다는 것이다.

#### 무질서한 코드

- 명확한 구조가 없으면, 특정 코드 파일이나 컴포넌트를 찾는 것이 어려워진다. 특히 프로젝트가 커질수록 관련 코드를 찾는 시간과 노력을 낭비할 수 있다.

#### 낮은 코드 재사용성

- 적절한 구조가 없다면, 재사용할 수 있는 컴포넌트나 기능을 식별하는 것이 쉽지 않다. 이는 코드 중복과 일관성 부족으로 이어질 수 있으며, 장기적으로 코드베이스를 유지하고 업데이트하기가 어려워진다.

#### 협업의 어려움

- 구조화가 덜 된 프로젝트를 진행하다 보면 팀원들이 서로의 코드를 이해하고 탐색하는 것이 더 어려워진다. 이로 인해 의사소통, 느린 개발 속도, 그리고 버그나 코드 변경 충돌을 일으킬 위험이 있다.

#### 확장성 문제

- 프로젝트가 커지고 새로운 기능이 늘어날수록 또 다른 구성 요소를 원활하게 기존 코드에 통합하는 것이 어려워진다. 확장과 수정이 어려운 꼬인 코드베이스가 되기 쉽고 생산성 감소와 개발 시간 증가로 이어진다.

#### 복잡한 유지 보수 문제

- 명확한 구조가 없는 코드베이스는 유지보수하기 어렵다. 코드를 구성하거나 이름 짓는 방식에 일관성이 부족하므로 기능을 변경하거나 문제를 해결할 때 더 많은 시간이 소요된다.

---

### 3.2 프런트엔드 애플리케이션의 복잡함에 대한 이해

리액트 프로젝트의 폴더 구조는 일반적인 리액트 코드베이스에서 관리해야 할 다양한 측면을 보여준다.

#### 소스 코드

- 애플리케이션의 핵심이며, 애플리케이션의 로직을 담고 있는 자바스크립트 또는 타입스크립트 파일, UI 구조를 위한 HTML 파일, 디자인을 표현하는 스타일 파일이 있다.
- 애플리케이션의 동작과 사용자 인터페이스를 정의하는 모든 것은 여기에서 찾을 수 있다.

#### 에셋

- 이 카테고리에는 애플리케이션에서 활용하는 이미지, 비디오, 폰트와 같은 모든 정적 파일이 있다.
- 이 파일들은 애플리케이션의 시각적 경험과 상호작용을 위해 필요하며, 전반적인 look and feel에 기여한다.

#### 설정:

- 이 파일들은 애플리케이션의 다양한 부분을 제어하는 중요한 매개변수를 포함한다.
- 의존성 목록을 관리하는 package.json과 프로젝트를 빌드할 때 필요한 환경변수는 애플리케이션을 운영하고 배포하는 데 중요하다.

#### 테스트

- 이 영역은 애플리케이션의 올바른 동작과 안정성을 위해 필요하다.
- 사용자 동작을 재현하고 상호작용을 검증하며 애플리케이션의 기능을 확인하는 유닛, 통합, E2E 테스트를 담고 있다. 이는 잠재적인 버그를 예방하는 데 도움이 된다.

#### 문서

- 프로젝트 개요를 제공하는 README 파일, API 문서와 코드 스타일 가이드 등 애플리케이션에 필요한 모든 정보가 문서에 있다.
- 프로젝트와 연관된 사람들은 문서를 통해 프로젝트를 쉽게 이해하고 코드의 일관성을 유지할 수 있다.

#### 빌드 결과물

- 배포 가능한 최적화된 번들 자바스크립트 CSS, HTML 그리고 디버깅에 도움이 되는 진단 파일과 임시 파일들을 포함한 빌드 실행 결과물이다.
- 애플리케이션을 최종 사용자에게 전달하는 핵심요소이다.

#### 개발 도구와 설정 파일

- 코드의 품질과 일정한 포맷을 유지하고 형상을 관리하여, 자동화된 테스팅과 배포 절차를 쉽게 해주는 도구다.
- 백그라운드로 작업이 수행되며, 원활하고 오류가 없는 효율적인 개발과정을 만들어준다.

이러한 다양한 구성 요소는 전형적인 리액트 코드베이스의 기초를 이루며, 중간 규모의 프런트엔드 프로젝트의 복잡함과 고려해야 할 사항들에 대해 잘 보여준다.

각각의 기능 폴더들을 살펴보면 다양한 요소들을 확인할 수 있다.

- Modal 대화창, 메뉴 탐색, 버튼, 카드 등 공용으로 사용하는 컴포넌트
- 메뉴 페이지에만 나타나는 특별 할인 정보를 위한 SpecialOffer 또는 애플 페이를 위한 Paywith Apple과 같은 특정 기능을 위한 컴포넌트
- CSS-in-JS 또는 SCSS/LESS를 이용한 스타일 정의
- 단위 테스트와 브라우저 테스트 같은 다양한 테스트 코드
- 유틸리티/헬퍼 함수로 만든 계산 로직
- 재사용하는 기능들을 모은 사용자 정의 훅
- 보안, 다국어(18), 그 외 특별한 목적의 컨텍스트
- Eslint 설정. jest 설정, webpack 설정과 같은 부가적인 설정 파일

다양한 파일이 많은 상황에서 쉽게 탐색하고 빠르게 수정하기 위해서는 코드베이스를 일관되게 정리하는 것이 큰 도움이 된다.

코드 요소의 이름을 짓고 구조화할 때는 일관성을 유지하는 것이 가장 중요하다. 어떤 방식을 선택하든, 프로젝트 전반에 걸쳐 일관된 방식을 유지해야 한다.

예를 들어 스타일 파일을 컴포넌트와 함께 배치하기로 정했다면, 이를 코드베이스의 모든 컴포넌트에 적용해야 한다.

tests 폴더에 테스트 파일을 보관한다면, 이 규칙을 모든 코드베이스에 일관되게
적용해야 한다.
예를 들어 테스트 파일을 나타내는 `__tests__`나 `specs`처럼 다른 형식의 규칙을 사용하면 일관성을 해치고 혼란을 일으킬 수 있으므로 피해야 한다.

---

### 3.3 일반적인 리액트 애플리케이션 구조

큰 규모의 리액트 애플리케이션의 구조를 만드는 방법 중 자주 사용되는 4가지 구조를 알아보자.

#### 기능 기반 구조

기능 기반 구조란 애플리케이션을 기능과 모듈 중심으로 구조화하는 것을 의미한다.

기능단위로 명확하게 분리하기 위해 컴포넌트와 뷰, API 호출, 상태 관리를 캡슐화하여 관리한다.

온라인 쇼핑을 기능 기반으로 구조화하면, 다음과 같은 폴더 구조를 가진다.

![alt text](<스크린샷 2025-05-16 오후 9.16.25.png>)

이 구조를 자세히 살펴보자.

- features 디렉터리는 Home, Cart, ProductDetails, Checkout, Profile 등과 같은 애플리케이션의 기능을 의미한다.
- 기능마다 components, containers, pages, services, types와 utils 폴더를 가진다.
- shared 디렉터리는 여러 기능에서 공유하여 재사용하는 components, containers, services, types, utils를 가진다.
- api 디렉터리는 API 호출을 하는 모듈을 가진다.
- store 디렉터리는 리덕스와 같은 상태 관리를 위한 모듈을 가진다.
- router 디렉터리는 라우팅 설정과 관련된 컴포넌트를 가진다.
- App.tsx 파일은 애플리케이션의 시작점이다.

이 구조의 장점은 다음과 같다.

##### 명확한 관심사분리

- 각 기능과 관련된 코드를 쉽게 찾고 수정할 수 있다.

##### 모듈화

- 기능 단위로 코드가 모여 있으므로 코드 테스팅과 유지보수, 재사용이 쉽다.

##### 확장성

- 새로운 기능이 추가될 때 기존 코드에 영향을 주지 않는다.

##### 팀 협업

- 여러 기능을 개발자들이 동시에 작업할 때 코드 충돌을 최소화할 수 있다.

하지만 다음과 같은 단점도 있다.

##### 코드 중복의 가능성

- 기능들이 비슷한 컴포넌트나 로직을 갖고 있으면 코드 중복이 발생할 수 있다. 신중하게 설계하거나 리팩터링을 통해 이를 피해야 한다.

---

### 컴포넌트 기반 구조

컴포넌트 기반 구조는 애플리케이션을 재사용할 수 있는 컴포넌트 단위로 구조화하는 것이다. 컴포넌트는 기능 단위로 분류하고 이를 조합하여 더 큰 뷰를 만든다.

![alt text](<스크린샷 2025-05-16 오후 9.22.42.png>)

이 구조를 자세히 살펴보자.

- components 폴더는 애플리케이션의 여러 기능에서 사용하는 개별 컴포넌트를 가지게 된다. 각각의 컴포넌트는 폴더에 존재하며, 필요할 경우 자식 컴포넌트를 가진다.
- routes 폴더는 애플리케이션의 프런트엔드 라우팅을 담당한다. 라우팅 로직을 설정하는 메인 AppRouter.tsx 파일, 개별 라우팅 경로와 그에 해당하는 컴포넌트를 담은 routes.tsx 파일이 이곳에 위치한다.
- api 폴더는 API 도메인이나 기능 단위의 파일을 가진다. products.ts, cart.ts, auth.ts, payment.ts 파일들은 각각의 도메인 API를 호출한다.
- 이 예제는 애플리케이션 전역 상태 관리를 위해 Redux나 리액트 Context API와 같은 라이브러리를 사용한다고 가정한다.

이 구조의 장점은 다음과 같다.

##### 모듈화

- 컴포넌트 기반 구조는 기능 단위의 컴포넌트를 별도의 파일과 폴더에 구분하여 모듈화한다. 이로 인해 코드를 유지보수하기 쉽고 재사용성이 높아진다.

##### 관심사 분리

- 컴포넌트의 개별 기능에 집중하게 되어 코드가 간결해지고 디버깅하기 쉽다. 관심사를 분리하면 유지보수하기 쉽고 코드 가독성이 높아진다.

##### 높은 코드 재사용성

- 애플리케이션의 여러 곳에서 컴포넌트를 재사용하고 이후 또 다른 프로젝트에서도 활용하여 개발 생산성을 높일 수 있다.

하지만 다음과 같은 단점도 있습니다.

##### 프로젝트 복잡도 증가

- 프로젝트가 커질수록 컴포넌트 폴더 구조가 복잡해지고 단순하게 유지하기 어렵다. 관리 가능한 수준을 유지하기 위해서는 모범사례를 참고하여 신중하게 설계하고 계획을 세워야 한다.

##### 높은 진입장벽

- 컴포넌트 기반의 개발과 타입스크립트에 익숙하지 않다면 초기 학습 곡선이 가파르게 올라간다.
- 하지만 초기 학습에 드는 비용보다 구조화된 코드가 가져다 주는 장점이 더 많다.

##### 코드 중복의 가능성

- components 폴더 안에서는 다른 컴포넌트와 동일하거나 기능이 유사한 컴포넌트를 찾기 쉽다.
- 컴포넌트를 더 잘게 나눌수록, 재사용할 수 있는 컴포넌트를 찾기 쉬워질 것이다.
- 재사용할 수 있는 컴포넌트가 점점 늘어난다면, 기능 기반 구조에서 보았던 대로 공유 폴더로 옮겨보는 것에 대해 고려해 볼 수 있다.

---

### 아토믹 디자인 구조

아토믹 디자인은 사용자 인터페이스를 체계화하는 디자인 방법론이다.

사용자 인터페이스를 atom이라고 부르는 재사용 가능한 작은 단위로 나누고 이를 합성하여 molecules, organisms, templates, pages 등의 큰 단위를 만들어낸다.

아토믹 디자인의 핵심 아이디어는 UI 컴포넌트를 만드는 체계적인 접근 방식을 설계하여 재사용성과 확장성, 유지보수성을 높이는 것이다.

컴포넌트를 구성하고 이름을 지정하기 위한 명확한 구조를 제시함으로써 UI 코드 베이스를 쉽게 이해하고 탐색할 수 있다.

아토믹 디자인 방법론에서 UI 컴포넌트를 어떻게 분류하는지 살펴보자.

##### 원자(atom)

- UI를 구성하는 가장 작은 요소이며 버튼, 인풋, 아이콘 또는 레이블 등의 기본 요소들이 있다. 보통 단순하며 독립된 단일 기능을 가진다.

##### 분자

- 원자들을 조합하여 복잡한 UI컴포넌트를 표현합니다. 여러 원자가 상호작용을 하여 기능 단위를 구성한다. 폼 입력, 내비게이션 바 등이 있다.

##### 유기체

- 더 커다란 컴포넌트이며 분자 또는 원자들을 결합하여 기능 영역의 UI를 표현한다.
- 헤더, 사이드 바, 카드 컴포넌트 등 사용자 인터페이스의 기능 영역을 표현한다.

##### 템플릿

- 분자 또는 유기체들을 배치하는 레이아웃 구조이다. 페이지의 전반적인 구조와 UI의 기능 영역을 표시한다.

##### 페이지

- 템플릿과 유기체, 분자, 원자 등을 모두 결합한 온전한 사용자 화면 구성 전체를 의미한다. 사용자에게 전달되는 최종 결과물이다.

![alt text](<스크린샷 2025-05-16 오후 9.31.37.png>)

#### 이 구조를 자세히 살펴보자.

- atoms, molecules, organisms, templates, pages 디렉터리는 컴포넌트 합성과 추상화의 다양한 레벨을 나타낸다.
- api 디렉터리는 API 호출과 관련된 파일을 담고 있다.
- views 디렉터리는 컴포넌트를 렌더링하는 개별 단위의 뷰 파일이 있다.
- routes 디렉터리는 라우팅 설정이 있다.

#### 이 방식은 다음과 같은 장점이 있다.

##### 재사용성

- 컴포넌트를 애플리케이션 전체에서 쉽게 재사용할 수 있어 코드 효율성이 높다.

##### 일관성

- UI 패턴과 디자인에 대한 일관된 적용이 가능하다.

##### 확장성

- 모듈화된 접근 방법을 통해 컴포넌트 기능 확장이 쉽고 신규 컴포넌트를 추가하기 용이하다.

##### 유지보수성

- 컴포넌트가 논리적으로 구조화되어 있어 찾거나 업데이트하기 쉽다.

##### 쉬운 협업

- 아토믹 디자인 구조는 디자이너와 개발자가 UI 컴포넌트에 관해 논의할 때 공통 언어의 역할을 하므로 협업하기 쉽다.

#### 반면에 단점은 다음과 같다.

##### 높은 진입장벽

- 아토믹 디자인 원칙을 효과적으로 구현하려면 초반에 학습과 적응 과정이 필요하다.

##### 복잡도

- 애플리케이션이 커질수록 컴포넌트 개수가 늘어나고 그 관계가 복잡해져서 관리가 어렵다.

##### 오버 엔지니어링

- 과도한 추상화는 필요 이상으로 구조를 복잡하게 만들기 때문에 컴포넌트 재사용성 과오버 엔지니어링 사이의 균형을 맞추는 것이 중요하다.

---

### MVVM(Model-View-ViewModel) 구조

MVVM 구조는 주로 사용자 인터페이스를 만드는 데 사용되는 아키텍처 패턴이다.

##### 모델

- 실제 다루는 데이터 또는 정보를 의미한다.
- 데이터베이스, 파일, 웹서비스 또는 단순한 객체일 수도 있다.

##### 뷰

- 사용자가 보면서 상호작용하는 것을 말한다.
- 모델을 사용자에게 보여주는 역할을 하는 것이 사용자 인터페이스이다.

##### 뷰모델

- 대부분의 로직이 위치하는 곳이다. 외부에 공개되는 속성과 명령이 있는 추상화된 뷰다.
- 뷰와 모델 사이의 차이를 메워주며, 모델의 데이터를 뷰가 쉽게 처리할 수 있는 형식으로 가공해준다.
- 데이터에 대한 작업을 수행하고 뷰에 어떻게 보여줄지를 결정한다.

![alt text](<스크린샷 2025-05-16 오후 9.39.02.png>)

#### 이 구조를 자세히 살펴보자.

- views 디렉터리에는 ViewModel의 상태에 따라 화면에 보여주는 UI컴포넌트가 있다.
- models 디렉터리에는 애플리케이션 도메인 객체를 나타내는 CartItemModel, ProductModel과 같은 데이터 모델 또는 엔티티(entity)가 있다.
- viewmodels 디렉터리에는 상태와 로직을 관리하고 뷰와 상호작용을 하는 훅이 있다.
- services 디렉터리에는 API 호출과 외부 서비스와의 연결을 위한 파일이 있다.
- components 디렉터리에는 각각의 기능 단위로 재사용 가능한 UI 컴포넌트가 있다.
- routers 디렉터리에는 라우팅 설정과 관련된 컴포넌트가 있다.
- App.tsx 파일은 애플리케이션의 진입점이다.

#### 이 방식은 다음과 같은 장점이 있다.

##### 관심사 분리

- 뷰모델은 UI 컴포넌트에서 비즈니스 로직을 분리하여, 유지보수하기 쉽고 깔끔한 코드를 작성할 수 있다.

##### 쉬운 테스팅

- 뷰모델은 실제 UI 컴포넌트 없이도 쉽게 단위 테스트가 가능하다.

##### 높은 재사용성

- 컴포넌트와 모델, 서비스는 다른 기능이나 뷰에서도 쉽게 재사용할 수 있다.

##### 높은 확장성

- 기존에 사용하던 뷰모델에 새로운 기능이나 뷰를 쉽게 추가할 수 있다.

#### 그리고 다음과 같은 단점도 존재한다.

##### 복잡도 증가

- MVVM 패턴을 도입하면 추상화 계층(abstraction layer)을 추가하게 되며, 특히 프로젝트 규모가 작다면 이로 인한 애플리케이션 복잡도가 증가한다.

##### 높은 진입장벽

- MVVM 개념과 사용법에 대한 이해가 필요하다.

---

### 3.4 프로젝트 구조를 체계적으로 유지하기

기능 기반의 구조는 프로젝트 초기에 유용한 전략이다. 프로젝트가 커지고 비슷한 패턴들이 반복되기 시작한다면, 추가 계층을 만들어 중복을 피할 수 있다.

예를 들면 온라인 쇼핑 애플리케이션에는 많은 페이지가 있다.

- 홈
- 로그인/회원 가입
- 스토어 주소 검색
- 상품 목록
- 장바구니
- 주문 내역
- 결제
- 사용자 프로필
- 쿠폰

#### 3.4.1 초기 설계 구현하기

src 디렉터리의 초기 폴더 구조는 매우 간단하며 기능 기반 접근 방식을 따른다. 각 페이지별 폴더가 구분된다.
![alt text](<스크린샷 2025-05-16 오후 9.56.36.png>)

하지만 프로젝트가 커질수록, 서로 다른 페이지에서 컴포넌트나 기능의 중복이 발생한다. 이를 해결하려면 추가로 추상화 계층을 도입해야 한다.

예를 들어 Login과 Order 페이지 모두 Button 컴포넌트가 필요하다고 페이지별로 각각 이를 구현하는 것은 실용적이지 않다.

Button 컴포넌트를 분리하여, components나 shared 폴더와 같은 별도의 계층에 넣을 수 있다.

---

#### 3.4.2 중복 제거를 위한 계층 추가

이렇게 계층을 추가하면, 코드 베이스의 재사용성과 유지보수성을 높일 수 있다.

프로젝트가 더 커지더라도 이런 모듈화된 접근 방식 덕분에 관리와 확장이 쉽고, 전체 코드 베이스에 영향을 주지 않으면서 신규 기능을 추가하거나 변경할 수 있다.

그러므로 다음과 같이 components 폴더에 재사용 가능한 모든 컴포넌트를 넣고, pages 폴더에 페이지와 관련된 모든 컴포넌트를 넣는다.

![alt text](<스크린샷 2025-05-16 오후 9.58.56.png>)

- 이 구조에서 컴포넌트는 각 기능의 이름을 가진 폴더 내에 구성되어 있기 때문에 모듈성과 코드 재사용성이 높아진다.
- 또한 Offer 폴더에 별도의 기능을 가진 SpecialOffer를 하위 폴더로 추가한 것처럼, 컴포넌트를 계층화하여 표현할 수 있다.

모든 컴포넌트를 components 폴더로 옮겨야 하는 건 아니다. 여러 페이지에서 중복되는 컴포넌트만 공유 폴더로 옮겨야 하며, 모듈성과 불필요한 복잡성 사이의 균형을 유지해야 한다.

이 파일 구조는 프로젝트 구조가 커지더라도 더 나은 조직화, 코드 재사용, 쉬운 코드 확장을 가능하게 한다. 따라서 중복을 줄이고 애플리케이션 내의 일관성을 유지할 수 있기 때문에 관리하기 쉽다.

또한 훅과 컨텍스트를 별도 폴더로 분리하기 때문에, 관련된 코드를 한곳에 모으고 전역 상태와 재사용하는 로직을 관리하기 용이하다.

---

#### 3.4.4 사용자 설정 구조 살펴보기

애플리케이션이 커지고 서로 다른 타입의 추상화 계층이 추가되면, 그에 걸맞는 프로젝트 구조화가 필요하다. 요구사항에 맞춰 앞서 소개했던 구조들을 변형하는 것이 종종 필요하다.

프로젝트 구조를 세우는 근본적인 목적은 개발 과정을 단순화하고 간소화하는 것이다.

기능 기반의 구조에서 시작했을 때, 이러한 변화를 반영하기 위해선 현재의 폴더 구조를 다음과 같이 변경해야 한다.

##### api

- 네트워크 요청을 발생시키고 응답을 다루며, 백엔드 서비스와 상호작용하는 API 관련 코드를 관리하는 모듈 또는 디렉터리이다.

##### components

- 애플리케이션에서 여러 페이지와 기능을 넘나들며 재사용 가능한 UI 컴포넌트가 있는 폴더이다.
- Accordion, Button, GenericCard, Modal, Offer, StackView와 같은 컴포넌트가 있다.
- 이 컴포넌트들은 기능이나 목적에 따라 서브 폴더로 다시 나뉘기도 한다.

##### context

- 전역 상태를 관리하고 컴포넌트 간에 데이터를 공유하게 해주는 리액트 컨텍스트 모듈이 위치한 폴더이다.

##### hooks

- 재사용 가능한 로직과 행위를 담고 있는 사용자 정의 리액트 훅이 있다.
- 이 훅은 애플리케이션의 전반에 걸쳐 공유될 수 있다.

##### mocks

- 테스팅 목적의 모킹 데이터 또는 모킹 구현체(implementation)를 가지고 있다.
- graphQL 데이터를 모킹하는 graphql 폴더와 REST API를 모킹하는 rest 서브 폴더가 있다.

##### pages

- 이 폴더는 애플리케이션의 다양한 페이지나 기능이 있다.
- 페이지 또는 기능 단위로 폴더가 있다.
- 폴더에는 Address, Home, Login, Order, Payment, Product, Profile, SignUp이 있으며, 하위에 서브 폴더가 있다.
- 서브 폴더는 페이지 또는 기능에 추가로 필요한 부가적인 컴포넌트와 훅 컨텍스트를 담고 있다.

이렇게 프로젝트의 구조를 세우면, 모듈화 되고 구조화된 코드베이스를 만들 수 있다. 이를 통해 코드 재사용성을 높이고, 관심사를 분리하고, 확장하기 쉬워진다.

각각의 디렉터리는 애플리케이션의 특정 부분을 나타내며 코드를 더 쉽게 찾고 관리할 수 있다.

다시 온라인 쇼핑 예제로 돌아가서, 다음과 같은 폴더 구조를 볼 수 있다.

![alt text](<스크린샷 2025-05-16 오후 10.07.12.png>)

- 이 구조는 단단한 기반을 갖추고 있지만, 프로젝트의 구체적인 요구사항 또는 확장에 따라 변경하는 것이 중요하다.
- 구조를 정기적으로 리뷰하고 리팩터링하여, 효율성을 유지하고 미래의 변경 가능성에 효과적으로 대비할 수 있다.

애플리케이션이 커지면, components 폴더를 공용 라이브러리로 분리하여 여러 프로젝트에서 함께 사용하거나 내부 디자인 시스템으로 활용하는 것이 유리할 수 있다.

또한 애플리케이션이 진화하고 새로운 기능이 추가되면, 기존의 구조는 더 이상 요구사항에 맞지 않을 수 있다.

이런 경우에는 계층화된 접근을 따르는 MVVM과 같은 구조의 패턴을 도입하는 것이 도움될 수 있다.
